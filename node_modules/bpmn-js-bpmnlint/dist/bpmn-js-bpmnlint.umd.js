(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.BpmnJSBpmnlint = factory());
})(this, (function () { 'use strict';

  function EditorActions(injector, linting) {
    var editorActions = injector.get('editorActions', false);

    editorActions && editorActions.register({
      toggleLinting: function() {
        linting.toggle();
      }
    });
  }

  EditorActions.$inject = [
    'injector',
    'linting'
  ];

  /**
   * @typedef { import('./types.js').ModdleElement } ModdleElement
   *
   * @typedef { (element: ModdleElement) => boolean | void } EnterFn
   * @typedef { (element: ModdleElement) => void } LeaveFn
   */

  var traverse;
  var hasRequiredTraverse;

  function requireTraverse () {
  	if (hasRequiredTraverse) return traverse;
  	hasRequiredTraverse = 1;
  	/**
  	 * Traverse a moddle tree, depth first from top to bottom
  	 * and call the passed visitor fn.
  	 *
  	 * @param { ModdleElement } element
  	 * @param { { enter?: EnterFn; leave?: LeaveFn } } options
  	 */
  	traverse = function traverse(element, options) {

  	  const enter = options.enter;
  	  const leave = options.leave;

  	  const enterSubTree = enter && enter(element);

  	  const descriptor = element.$descriptor;

  	  if (enterSubTree !== false && !descriptor.isGeneric) {

  	    const containedProperties = descriptor.properties.filter(p => {
  	      return !p.isAttr && !p.isReference && p.type !== 'String';
  	    });

  	    containedProperties.forEach(p => {
  	      if (p.name in element) {
  	        const propertyValue = element[p.name];

  	        if (p.isMany) {
  	          propertyValue.forEach(child => {
  	            traverse(child, options);
  	          });
  	        } else {
  	          traverse(propertyValue, options);
  	        }
  	      }
  	    });
  	  }

  	  leave && leave(element);
  	};
  	return traverse;
  }

  var dist = {};

  var hasRequiredDist;

  function requireDist () {
  	if (hasRequiredDist) return dist;
  	hasRequiredDist = 1;

  	/**
  	 * Flatten array, one level deep.
  	 *
  	 * @template T
  	 *
  	 * @param {T[][] | T[] | null} [arr]
  	 *
  	 * @return {T[]}
  	 */
  	function flatten(arr) {
  	  return Array.prototype.concat.apply([], arr);
  	}

  	const nativeToString = Object.prototype.toString;
  	const nativeHasOwnProperty = Object.prototype.hasOwnProperty;

  	function isUndefined(obj) {
  	  return obj === undefined;
  	}

  	function isDefined(obj) {
  	  return obj !== undefined;
  	}

  	function isNil(obj) {
  	  return obj == null;
  	}

  	function isArray(obj) {
  	  return nativeToString.call(obj) === '[object Array]';
  	}

  	function isObject(obj) {
  	  return nativeToString.call(obj) === '[object Object]';
  	}

  	function isNumber(obj) {
  	  return nativeToString.call(obj) === '[object Number]';
  	}

  	/**
  	 * @param {any} obj
  	 *
  	 * @return {boolean}
  	 */
  	function isFunction(obj) {
  	  const tag = nativeToString.call(obj);

  	  return (
  	    tag === '[object Function]' ||
  	    tag === '[object AsyncFunction]' ||
  	    tag === '[object GeneratorFunction]' ||
  	    tag === '[object AsyncGeneratorFunction]' ||
  	    tag === '[object Proxy]'
  	  );
  	}

  	function isString(obj) {
  	  return nativeToString.call(obj) === '[object String]';
  	}


  	/**
  	 * Ensure collection is an array.
  	 *
  	 * @param {Object} obj
  	 */
  	function ensureArray(obj) {

  	  if (isArray(obj)) {
  	    return;
  	  }

  	  throw new Error('must supply array');
  	}

  	/**
  	 * Return true, if target owns a property with the given key.
  	 *
  	 * @param {Object} target
  	 * @param {String} key
  	 *
  	 * @return {Boolean}
  	 */
  	function has(target, key) {
  	  return !isNil(target) && nativeHasOwnProperty.call(target, key);
  	}

  	/**
  	 * @template T
  	 * @typedef { (
  	 *   ((e: T) => boolean) |
  	 *   ((e: T, idx: number) => boolean) |
  	 *   ((e: T, key: string) => boolean) |
  	 *   string |
  	 *   number
  	 * ) } Matcher
  	 */

  	/**
  	 * @template T
  	 * @template U
  	 *
  	 * @typedef { (
  	 *   ((e: T) => U) | string | number
  	 * ) } Extractor
  	 */


  	/**
  	 * @template T
  	 * @typedef { (val: T, key: any) => boolean } MatchFn
  	 */

  	/**
  	 * @template T
  	 * @typedef { T[] } ArrayCollection
  	 */

  	/**
  	 * @template T
  	 * @typedef { { [key: string]: T } } StringKeyValueCollection
  	 */

  	/**
  	 * @template T
  	 * @typedef { { [key: number]: T } } NumberKeyValueCollection
  	 */

  	/**
  	 * @template T
  	 * @typedef { StringKeyValueCollection<T> | NumberKeyValueCollection<T> } KeyValueCollection
  	 */

  	/**
  	 * @template T
  	 * @typedef { KeyValueCollection<T> | ArrayCollection<T> } Collection
  	 */

  	/**
  	 * Find element in collection.
  	 *
  	 * @template T
  	 * @param {Collection<T>} collection
  	 * @param {Matcher<T>} matcher
  	 *
  	 * @return {Object}
  	 */
  	function find(collection, matcher) {

  	  const matchFn = toMatcher(matcher);

  	  let match;

  	  forEach(collection, function(val, key) {
  	    if (matchFn(val, key)) {
  	      match = val;

  	      return false;
  	    }
  	  });

  	  return match;

  	}


  	/**
  	 * Find element index in collection.
  	 *
  	 * @template T
  	 * @param {Collection<T>} collection
  	 * @param {Matcher<T>} matcher
  	 *
  	 * @return {number | string | undefined}
  	 */
  	function findIndex(collection, matcher) {

  	  const matchFn = toMatcher(matcher);

  	  let idx = isArray(collection) ? -1 : undefined;

  	  forEach(collection, function(val, key) {
  	    if (matchFn(val, key)) {
  	      idx = key;

  	      return false;
  	    }
  	  });

  	  return idx;
  	}


  	/**
  	 * Filter elements in collection.
  	 *
  	 * @template T
  	 * @param {Collection<T>} collection
  	 * @param {Matcher<T>} matcher
  	 *
  	 * @return {T[]} result
  	 */
  	function filter(collection, matcher) {

  	  const matchFn = toMatcher(matcher);

  	  let result = [];

  	  forEach(collection, function(val, key) {
  	    if (matchFn(val, key)) {
  	      result.push(val);
  	    }
  	  });

  	  return result;
  	}


  	/**
  	 * Iterate over collection; returning something
  	 * (non-undefined) will stop iteration.
  	 *
  	 * @template T
  	 * @param {Collection<T>} collection
  	 * @param { ((item: T, idx: number) => (boolean|void)) | ((item: T, key: string) => (boolean|void)) } iterator
  	 *
  	 * @return {T} return result that stopped the iteration
  	 */
  	function forEach(collection, iterator) {

  	  let val,
  	      result;

  	  if (isUndefined(collection)) {
  	    return;
  	  }

  	  const convertKey = isArray(collection) ? toNum : identity;

  	  for (let key in collection) {

  	    if (has(collection, key)) {
  	      val = collection[key];

  	      result = iterator(val, convertKey(key));

  	      if (result === false) {
  	        return val;
  	      }
  	    }
  	  }
  	}

  	/**
  	 * Return collection without element.
  	 *
  	 * @template T
  	 * @param {ArrayCollection<T>} arr
  	 * @param {Matcher<T>} matcher
  	 *
  	 * @return {T[]}
  	 */
  	function without(arr, matcher) {

  	  if (isUndefined(arr)) {
  	    return [];
  	  }

  	  ensureArray(arr);

  	  const matchFn = toMatcher(matcher);

  	  return arr.filter(function(el, idx) {
  	    return !matchFn(el, idx);
  	  });

  	}


  	/**
  	 * Reduce collection, returning a single result.
  	 *
  	 * @template T
  	 * @template V
  	 *
  	 * @param {Collection<T>} collection
  	 * @param {(result: V, entry: T, index: any) => V} iterator
  	 * @param {V} result
  	 *
  	 * @return {V} result returned from last iterator
  	 */
  	function reduce(collection, iterator, result) {

  	  forEach(collection, function(value, idx) {
  	    result = iterator(result, value, idx);
  	  });

  	  return result;
  	}


  	/**
  	 * Return true if every element in the collection
  	 * matches the criteria.
  	 *
  	 * @param  {Object|Array} collection
  	 * @param  {Function} matcher
  	 *
  	 * @return {Boolean}
  	 */
  	function every(collection, matcher) {

  	  return !!reduce(collection, function(matches, val, key) {
  	    return matches && matcher(val, key);
  	  }, true);
  	}


  	/**
  	 * Return true if some elements in the collection
  	 * match the criteria.
  	 *
  	 * @param  {Object|Array} collection
  	 * @param  {Function} matcher
  	 *
  	 * @return {Boolean}
  	 */
  	function some(collection, matcher) {

  	  return !!find(collection, matcher);
  	}


  	/**
  	 * Transform a collection into another collection
  	 * by piping each member through the given fn.
  	 *
  	 * @param  {Object|Array}   collection
  	 * @param  {Function} fn
  	 *
  	 * @return {Array} transformed collection
  	 */
  	function map(collection, fn) {

  	  let result = [];

  	  forEach(collection, function(val, key) {
  	    result.push(fn(val, key));
  	  });

  	  return result;
  	}


  	/**
  	 * Get the collections keys.
  	 *
  	 * @param  {Object|Array} collection
  	 *
  	 * @return {Array}
  	 */
  	function keys(collection) {
  	  return collection && Object.keys(collection) || [];
  	}


  	/**
  	 * Shorthand for `keys(o).length`.
  	 *
  	 * @param  {Object|Array} collection
  	 *
  	 * @return {Number}
  	 */
  	function size(collection) {
  	  return keys(collection).length;
  	}


  	/**
  	 * Get the values in the collection.
  	 *
  	 * @param  {Object|Array} collection
  	 *
  	 * @return {Array}
  	 */
  	function values(collection) {
  	  return map(collection, (val) => val);
  	}


  	/**
  	 * Group collection members by attribute.
  	 *
  	 * @param {Object|Array} collection
  	 * @param {Extractor} extractor
  	 *
  	 * @return {Object} map with { attrValue => [ a, b, c ] }
  	 */
  	function groupBy(collection, extractor, grouped = {}) {

  	  extractor = toExtractor(extractor);

  	  forEach(collection, function(val) {
  	    let discriminator = extractor(val) || '_';

  	    let group = grouped[discriminator];

  	    if (!group) {
  	      group = grouped[discriminator] = [];
  	    }

  	    group.push(val);
  	  });

  	  return grouped;
  	}


  	function uniqueBy(extractor, ...collections) {

  	  extractor = toExtractor(extractor);

  	  let grouped = {};

  	  forEach(collections, (c) => groupBy(c, extractor, grouped));

  	  let result = map(grouped, function(val, key) {
  	    return val[0];
  	  });

  	  return result;
  	}


  	const unionBy = uniqueBy;



  	/**
  	 * Sort collection by criteria.
  	 *
  	 * @template T
  	 *
  	 * @param {Collection<T>} collection
  	 * @param {Extractor<T, number | string>} extractor
  	 *
  	 * @return {Array}
  	 */
  	function sortBy(collection, extractor) {

  	  extractor = toExtractor(extractor);

  	  let sorted = [];

  	  forEach(collection, function(value, key) {
  	    let disc = extractor(value, key);

  	    let entry = {
  	      d: disc,
  	      v: value
  	    };

  	    for (var idx = 0; idx < sorted.length; idx++) {
  	      let { d } = sorted[idx];

  	      if (disc < d) {
  	        sorted.splice(idx, 0, entry);
  	        return;
  	      }
  	    }

  	    // not inserted, append (!)
  	    sorted.push(entry);
  	  });

  	  return map(sorted, (e) => e.v);
  	}


  	/**
  	 * Create an object pattern matcher.
  	 *
  	 * @example
  	 *
  	 * ```javascript
  	 * const matcher = matchPattern({ id: 1 });
  	 *
  	 * let element = find(elements, matcher);
  	 * ```
  	 *
  	 * @template T
  	 *
  	 * @param {T} pattern
  	 *
  	 * @return { (el: any) =>  boolean } matcherFn
  	 */
  	function matchPattern(pattern) {

  	  return function(el) {

  	    return every(pattern, function(val, key) {
  	      return el[key] === val;
  	    });

  	  };
  	}


  	/**
  	 * @param {string | ((e: any) => any) } extractor
  	 *
  	 * @return { (e: any) => any }
  	 */
  	function toExtractor(extractor) {

  	  /**
  	   * @satisfies { (e: any) => any }
  	   */
  	  return isFunction(extractor) ? extractor : (e) => {

  	    // @ts-ignore: just works
  	    return e[extractor];
  	  };
  	}


  	/**
  	 * @template T
  	 * @param {Matcher<T>} matcher
  	 *
  	 * @return {MatchFn<T>}
  	 */
  	function toMatcher(matcher) {
  	  return isFunction(matcher) ? matcher : (e) => {
  	    return e === matcher;
  	  };
  	}


  	function identity(arg) {
  	  return arg;
  	}

  	function toNum(arg) {
  	  return Number(arg);
  	}

  	/* global setTimeout clearTimeout */

  	/**
  	 * @typedef { {
  	 *   (...args: any[]): any;
  	 *   flush: () => void;
  	 *   cancel: () => void;
  	 * } } DebouncedFunction
  	 */

  	/**
  	 * Debounce fn, calling it only once if the given time
  	 * elapsed between calls.
  	 *
  	 * Lodash-style the function exposes methods to `#clear`
  	 * and `#flush` to control internal behavior.
  	 *
  	 * @param  {Function} fn
  	 * @param  {Number} timeout
  	 *
  	 * @return {DebouncedFunction} debounced function
  	 */
  	function debounce(fn, timeout) {

  	  let timer;

  	  let lastArgs;
  	  let lastThis;

  	  let lastNow;

  	  function fire(force) {

  	    let now = Date.now();

  	    let scheduledDiff = force ? 0 : (lastNow + timeout) - now;

  	    if (scheduledDiff > 0) {
  	      return schedule(scheduledDiff);
  	    }

  	    fn.apply(lastThis, lastArgs);

  	    clear();
  	  }

  	  function schedule(timeout) {
  	    timer = setTimeout(fire, timeout);
  	  }

  	  function clear() {
  	    if (timer) {
  	      clearTimeout(timer);
  	    }

  	    timer = lastNow = lastArgs = lastThis = undefined;
  	  }

  	  function flush() {
  	    if (timer) {
  	      fire(true);
  	    }

  	    clear();
  	  }

  	  /**
  	   * @type { DebouncedFunction }
  	   */
  	  function callback(...args) {
  	    lastNow = Date.now();

  	    lastArgs = args;
  	    lastThis = this;

  	    // ensure an execution is scheduled
  	    if (!timer) {
  	      schedule(timeout);
  	    }
  	  }

  	  callback.flush = flush;
  	  callback.cancel = clear;

  	  return callback;
  	}

  	/**
  	 * Throttle fn, calling at most once
  	 * in the given interval.
  	 *
  	 * @param  {Function} fn
  	 * @param  {Number} interval
  	 *
  	 * @return {Function} throttled function
  	 */
  	function throttle(fn, interval) {
  	  let throttling = false;

  	  return function(...args) {

  	    if (throttling) {
  	      return;
  	    }

  	    fn(...args);
  	    throttling = true;

  	    setTimeout(() => {
  	      throttling = false;
  	    }, interval);
  	  };
  	}

  	/**
  	 * Bind function against target <this>.
  	 *
  	 * @param  {Function} fn
  	 * @param  {Object}   target
  	 *
  	 * @return {Function} bound function
  	 */
  	function bind(fn, target) {
  	  return fn.bind(target);
  	}

  	/**
  	 * Convenience wrapper for `Object.assign`.
  	 *
  	 * @param {Object} target
  	 * @param {...Object} others
  	 *
  	 * @return {Object} the target
  	 */
  	function assign(target, ...others) {
  	  return Object.assign(target, ...others);
  	}

  	/**
  	 * Sets a nested property of a given object to the specified value.
  	 *
  	 * This mutates the object and returns it.
  	 *
  	 * @template T
  	 *
  	 * @param {T} target The target of the set operation.
  	 * @param {(string|number)[]} path The path to the nested value.
  	 * @param {any} value The value to set.
  	 *
  	 * @return {T}
  	 */
  	function set(target, path, value) {

  	  let currentTarget = target;

  	  forEach(path, function(key, idx) {

  	    if (typeof key !== 'number' && typeof key !== 'string') {
  	      throw new Error('illegal key type: ' + typeof key + '. Key should be of type number or string.');
  	    }

  	    if (key === 'constructor') {
  	      throw new Error('illegal key: constructor');
  	    }

  	    if (key === '__proto__') {
  	      throw new Error('illegal key: __proto__');
  	    }

  	    let nextKey = path[idx + 1];
  	    let nextTarget = currentTarget[key];

  	    if (isDefined(nextKey) && isNil(nextTarget)) {
  	      nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];
  	    }

  	    if (isUndefined(nextKey)) {
  	      if (isUndefined(value)) {
  	        delete currentTarget[key];
  	      } else {
  	        currentTarget[key] = value;
  	      }
  	    } else {
  	      currentTarget = nextTarget;
  	    }
  	  });

  	  return target;
  	}


  	/**
  	 * Gets a nested property of a given object.
  	 *
  	 * @param {Object} target The target of the get operation.
  	 * @param {(string|number)[]} path The path to the nested value.
  	 * @param {any} [defaultValue] The value to return if no value exists.
  	 *
  	 * @return {any}
  	 */
  	function get(target, path, defaultValue) {

  	  let currentTarget = target;

  	  forEach(path, function(key) {

  	    // accessing nil property yields <undefined>
  	    if (isNil(currentTarget)) {
  	      currentTarget = undefined;

  	      return false;
  	    }

  	    currentTarget = currentTarget[key];
  	  });

  	  return isUndefined(currentTarget) ? defaultValue : currentTarget;
  	}

  	/**
  	 * Pick properties from the given target.
  	 *
  	 * @template T
  	 * @template {any[]} V
  	 *
  	 * @param {T} target
  	 * @param {V} properties
  	 *
  	 * @return Pick<T, V>
  	 */
  	function pick(target, properties) {

  	  let result = {};

  	  let obj = Object(target);

  	  forEach(properties, function(prop) {

  	    if (prop in obj) {
  	      result[prop] = target[prop];
  	    }
  	  });

  	  return result;
  	}

  	/**
  	 * Pick all target properties, excluding the given ones.
  	 *
  	 * @template T
  	 * @template {any[]} V
  	 *
  	 * @param {T} target
  	 * @param {V} properties
  	 *
  	 * @return {Omit<T, V>} target
  	 */
  	function omit(target, properties) {

  	  let result = {};

  	  let obj = Object(target);

  	  forEach(obj, function(prop, key) {

  	    if (properties.indexOf(key) === -1) {
  	      result[key] = prop;
  	    }
  	  });

  	  return result;
  	}

  	/**
  	 * Recursively merge `...sources` into given target.
  	 *
  	 * Does support merging objects; does not support merging arrays.
  	 *
  	 * @param {Object} target
  	 * @param {...Object} sources
  	 *
  	 * @return {Object} the target
  	 */
  	function merge(target, ...sources) {

  	  if (!sources.length) {
  	    return target;
  	  }

  	  forEach(sources, function(source) {

  	    // skip non-obj sources, i.e. null
  	    if (!source || !isObject(source)) {
  	      return;
  	    }

  	    forEach(source, function(sourceVal, key) {

  	      if (key === '__proto__') {
  	        return;
  	      }

  	      let targetVal = target[key];

  	      if (isObject(sourceVal)) {

  	        if (!isObject(targetVal)) {

  	          // override target[key] with object
  	          targetVal = {};
  	        }

  	        target[key] = merge(targetVal, sourceVal);
  	      } else {
  	        target[key] = sourceVal;
  	      }

  	    });
  	  });

  	  return target;
  	}

  	dist.assign = assign;
  	dist.bind = bind;
  	dist.debounce = debounce;
  	dist.ensureArray = ensureArray;
  	dist.every = every;
  	dist.filter = filter;
  	dist.find = find;
  	dist.findIndex = findIndex;
  	dist.flatten = flatten;
  	dist.forEach = forEach;
  	dist.get = get;
  	dist.groupBy = groupBy;
  	dist.has = has;
  	dist.isArray = isArray;
  	dist.isDefined = isDefined;
  	dist.isFunction = isFunction;
  	dist.isNil = isNil;
  	dist.isNumber = isNumber;
  	dist.isObject = isObject;
  	dist.isString = isString;
  	dist.isUndefined = isUndefined;
  	dist.keys = keys;
  	dist.map = map;
  	dist.matchPattern = matchPattern;
  	dist.merge = merge;
  	dist.omit = omit;
  	dist.pick = pick;
  	dist.reduce = reduce;
  	dist.set = set;
  	dist.size = size;
  	dist.some = some;
  	dist.sortBy = sortBy;
  	dist.throttle = throttle;
  	dist.unionBy = unionBy;
  	dist.uniqueBy = uniqueBy;
  	dist.values = values;
  	dist.without = without;
  	return dist;
  }

  var testRule;
  var hasRequiredTestRule;

  function requireTestRule () {
  	if (hasRequiredTestRule) return testRule;
  	hasRequiredTestRule = 1;
  	const traverse = requireTraverse();

  	const {
  	  isArray,
  	  isObject,
  	  isFunction
  	} = /*@__PURE__*/ requireDist();


  	/**
  	 * @typedef { import('./types.js').EnterFn } EnterFn
  	 * @typedef { import('./types.js').ModdleElement } ModdleElement
  	 * @typedef { import('./types.js').RuleDefinition } RuleDefinition
  	 * @typedef { import('./types.js').Report } Report
  	 */


  	class Reporter {

  	  /**
  	   * @param { {
  	   *   moddleRoot: ModdleElement,
  	   *   rule: RuleDefinition
  	   * } } options
  	   */
  	  constructor({ moddleRoot, rule }) {
  	    this.rule = rule;
  	    this.moddleRoot = moddleRoot;

  	    /**
  	     * @type { Report[] }
  	     */
  	    this.messages = [];

  	    this.report = this.report.bind(this);
  	  }

  	  /**
  	   * @param { string } id
  	   * @param { string } message
  	   * @param { string[] | { path?: string[], [key: string]: any } } [path]
  	   *
  	   * @example
  	   *
  	   * ```javascript
  	   * reporter.report('foo', 'Foo error', [ 'foo', 'bar', 'baz' ]);
  	   *
  	   * reporter.report('foo', 'Foo error', {
  	   *   path: [ 'foo', 'bar', 'baz' ],
  	   *   foo: 'foo'
  	   * });
  	   * ```
  	   */
  	  report(id, message, path) {
  	    let report = {
  	      id,
  	      message
  	    };

  	    if (path && isArray(path)) {
  	      report = {
  	        ...report,
  	        path
  	      };
  	    }

  	    if (path && isObject(path)) {
  	      report = {
  	        ...report,
  	        ...path
  	      };
  	    }

  	    this.messages.push(report);
  	  }
  	}

  	/**
  	 * @param { {
  	 *   moddleRoot: ModdleElement,
  	 *   rule: RuleDefinition,
  	 *   config: any
  	 * } } options
  	 *
  	 * @return { Report[] } lint reports
  	 */
  	testRule = function testRule({ moddleRoot, rule }) {
  	  const reporter = new Reporter({ rule, moddleRoot });

  	  const check = rule.check || {};

  	  const leave = 'leave' in check ? check.leave : undefined;
  	  const enter = 'enter' in check ? check.enter : (
  	    isFunction(check) ? check : undefined
  	  );

  	  if (!enter && !leave) {
  	    throw new Error('no check implemented');
  	  }

  	  traverse(moddleRoot, {
  	    enter: enter ? (node) => enter(node, reporter) : undefined,
  	    leave: leave ? (node) => leave(node, reporter) : undefined
  	  });

  	  return reporter.messages;
  	};
  	return testRule;
  }

  var linter;
  var hasRequiredLinter;

  function requireLinter () {
  	if (hasRequiredLinter) return linter;
  	hasRequiredLinter = 1;
  	const testRule = requireTestRule();


  	/**
  	 * @typedef { import('./types.js').ModdleElement } ModdleElement
  	 *
  	 * @typedef { import('./types.js').ReportingCategory } ReportingCategory
  	 * @typedef { import('./types.js').ReportingCategoryMap } ReportingCategoryMap
  	 * @typedef { import('./types.js').RuleErrorCategory } RuleErrorCategory
  	 *
  	 * @typedef { import('./types.js').Resolver } Resolver
  	 * @typedef { import('./types.js').Config } Config
  	 *
  	 * @typedef { import('./types.js').RuleFactory } RuleFactory
  	 *
  	 * @typedef { import('./types.js').RuleDefinition } RuleDefinition
  	 * @typedef { import('./types.js').RuleConfigs } RuleConfigs
  	 * @typedef { import('./types.js').RuleConfig } RuleConfig
  	 *
  	 * @typedef { {
  	 *   name: string,
  	 *   rule: RuleDefinition,
  	 *   config: any,
  	 *   category: ReportingCategory
  	 * } } ResolvedRuleDefinition
  	 *
  	 * @typedef { import('./types.js').Report } Report
  	 * @typedef { Report & Pick<RuleDefinition, 'meta'> & {
  	 *   category: ReportingCategory | RuleErrorCategory
  	 * } } AnnotatedReport
  	 *
  	 * @typedef { import('./types.js').TransformRuleFn } TransformRuleFn
  	 *
  	 * @typedef { Record<string, AnnotatedReport[]> } LintResults
  	 */


  	/**
  	 * Transform a rule after it is loaded.
  	 *
  	 * @param { RuleDefinition } rule
  	 * @param { { pkg: string, ruleName: string } } options
  	 */
  	const noopTransformRule = (rule, options) => {
  	  return rule;
  	};


  	/**
  	 * @typeof { ReportingCategoryMap }
  	 */
  	const categoryMap = {
  	  0: 'off',
  	  1: 'warn',
  	  2: 'error',
  	  3: 'info'
  	};

  	/**
  	 * @type { RuleErrorCategory }
  	 */
  	const ruleErrorCategory = 'rule-error';

  	/**
  	 * @param { {
  	 *   config?: Config,
  	 *   resolver: Resolver,
  	 *   transformRule?: TransformRuleFn
  	 * } } options
  	 */
  	function Linter(options) {

  	  const {
  	    config = {},
  	    resolver,
  	    transformRule = noopTransformRule
  	  } = options || {};

  	  if (typeof resolver === 'undefined') {
  	    throw new Error('must provide <options.resolver>');
  	  }

  	  this.config = config;
  	  this.resolver = resolver;

  	  this.transformRule = transformRule;

  	  /**
  	   * @type { Record<string, RuleDefinition> }
  	   */
  	  this.cachedRules = {};

  	  /**
  	   * @type { Record<string, Config> }
  	   */
  	  this.cachedConfigs = {};
  	}


  	linter = Linter;

  	/**
  	 * Applies a rule on the moddleRoot and adds reports to the finalReport
  	 *
  	 * @param { ModdleElement } moddleRoot
  	 *
  	 * @param { ResolvedRuleDefinition } ruleDefinition
  	 *
  	 * @return { AnnotatedReport[] } reports
  	 */
  	Linter.prototype.applyRule = function applyRule(moddleRoot, ruleDefinition) {

  	  const {
  	    config,
  	    rule,
  	    category,
  	    name
  	  } = ruleDefinition;

  	  try {

  	    const reports = testRule({
  	      moddleRoot,
  	      rule,
  	      config
  	    });

  	    return reports.map(function(report) {
  	      return {
  	        ...report,
  	        meta: rule.meta,
  	        category
  	      };
  	    });
  	  } catch (e) {
  	    console.error('rule <' + name + '> failed with error: ', e);

  	    return [
  	      {
  	        message: /** @type { Error } */ (e).message,
  	        category: ruleErrorCategory
  	      }
  	    ];
  	  }

  	};


  	/**
  	 * @param { string } name
  	 * @param  { RuleConfig } config
  	 *
  	 * @return { Promise<RuleDefinition> }
  	 */
  	Linter.prototype.resolveRule = function(name, config) {

  	  const {
  	    pkg,
  	    ruleName
  	  } = this.parseRuleName(name);

  	  const id = `${pkg}-${ruleName}`;

  	  const rule = this.cachedRules[id];

  	  if (rule) {
  	    return Promise.resolve(rule);
  	  }

  	  return Promise.resolve(this.resolver.resolveRule(pkg, ruleName)).then((ruleFactory) => {

  	    if (!ruleFactory) {
  	      throw new Error(`unknown rule <${name}>`);
  	    }

  	    const rule = this.cachedRules[id] = this.transformRule(ruleFactory(config), { pkg, ruleName });

  	    return rule;
  	  });
  	};

  	/**
  	 * @param {string} name
  	 *
  	 * @return {Promise<Config>}
  	 */
  	Linter.prototype.resolveConfig = function(name) {

  	  const {
  	    pkg,
  	    configName
  	  } = this.parseConfigName(name);

  	  const id = `${pkg}-${configName}`;

  	  const config = this.cachedConfigs[id];

  	  if (config) {
  	    return Promise.resolve(config);
  	  }

  	  return Promise.resolve(this.resolver.resolveConfig(pkg, configName)).then((config) => {

  	    if (!config) {
  	      throw new Error(`unknown config <${name}>`);
  	    }

  	    const actualConfig = this.cachedConfigs[id] = this.normalizeConfig(config, pkg);

  	    return actualConfig;
  	  });
  	};

  	/**
  	 * Take a linter config and return list of resolved rules.
  	 *
  	 * @param { Config } config
  	 *
  	 * @return { Promise<ResolvedRuleDefinition[]> }
  	 */
  	Linter.prototype.resolveRules = function(config) {

  	  return this.resolveConfiguredRules(config).then((rulesConfig) => {

  	    // parse rule values
  	    const parsedRules = Object.entries(rulesConfig).map(([ name, value ]) => {
  	      const {
  	        category,
  	        config
  	      } = this.parseRuleValue(value);

  	      return {
  	        name,
  	        category,
  	        config
  	      };
  	    });

  	    // filter only for enabled rules
  	    const enabledRules = parsedRules.filter(definition => definition.category !== 'off');

  	    // load enabled rules
  	    const loaders = enabledRules.map((definition) => {

  	      const {
  	        name,
  	        config
  	      } = definition;

  	      return this.resolveRule(name, config).then(function(rule) {
  	        return {
  	          ...definition,
  	          rule
  	        };
  	      });
  	    });

  	    return Promise.all(loaders);
  	  });
  	};

  	/**
  	 * @param { Config } config
  	 *
  	 * @return { Promise<RuleConfigs> }
  	 */
  	Linter.prototype.resolveConfiguredRules = function(config) {

  	  let parents = config.extends;

  	  if (typeof parents === 'string') {
  	    parents = [ parents ];
  	  }

  	  if (typeof parents === 'undefined') {
  	    parents = [];
  	  }

  	  return Promise.all(
  	    parents.map((configName) => {
  	      return this.resolveConfig(configName).then((config) => {
  	        return this.resolveConfiguredRules(config);
  	      });
  	    })
  	  ).then((inheritedRules) => {

  	    const overrideRules = this.normalizeConfig(config, 'bpmnlint').rules;

  	    const rules = [ ...inheritedRules, overrideRules ].reduce((rules, currentRules) => {
  	      return {
  	        ...rules,
  	        ...currentRules
  	      };
  	    }, {});

  	    return rules;
  	  });
  	};


  	/**
  	 * Lint the given model root, using the specified linter config.
  	 *
  	 * @param { ModdleElement } moddleRoot
  	 * @param { Config } [config] the bpmnlint configuration to use
  	 *
  	 * @return { Promise<LintResults> } lint results, keyed by rule names
  	 */
  	Linter.prototype.lint = function(moddleRoot, config) {

  	  config = config || this.config;

  	  // load rules
  	  return this.resolveRules(config).then((ruleDefinitions) => {

  	    /**
  	     * @type { LintResults }
  	     */
  	    const allReports = {};

  	    ruleDefinitions.forEach((ruleDefinition) => {

  	      const {
  	        name
  	      } = ruleDefinition;

  	      const reports = this.applyRule(moddleRoot, ruleDefinition);

  	      if (reports.length) {
  	        allReports[name] = reports;
  	      }
  	    });

  	    return allReports;
  	  });
  	};

  	/**
  	 * @param { import('./types.js').RuleConfig } value
  	 *
  	 * @return { { config: any, category: ReportingCategory } }
  	 */
  	Linter.prototype.parseRuleValue = function(value) {

  	  let category;
  	  let config;

  	  if (Array.isArray(value)) {
  	    category = value[0];
  	    config = value[1];
  	  } else {
  	    category = value;
  	    config = {};
  	  }

  	  // normalize rule flag to <error> and <warn> which
  	  // may be upper case or a number at this point
  	  if (typeof category === 'string') {
  	    category = category.toLowerCase();
  	  }

  	  category = categoryMap[category] || category;

  	  return {
  	    config,
  	    category
  	  };
  	};

  	Linter.prototype.parseRuleName = function(name, localPackage = 'bpmnlint') {

  	  /**
  	   * We recognize the following rule name patterns:
  	   *
  	   * {RULE_NAME} => PKG = 'bpmnlint'
  	   * bpmnlint/{RULE_NAME} => PKG = 'bpmnlint'
  	   * {PACKAGE_SHORTCUT}/{RULE_NAME} => PKG = 'bpmnlint-plugin-{PACKAGE_SHORTCUT}'
  	   * bpmnlint-plugin-{PACKAGE_SHORTCUT}/{RULE_NAME} => PKG = 'bpmnlint-plugin-{PACKAGE_SHORTCUT}'
  	   * @scope/{PACKAGE_SHORTCUT}/{RULE_NAME} => PKG = '@scope/bpmnlint-plugin-{PACKAGE_SHORTCUT}'
  	   * @scope/bpmnlint-plugin-{PACKAGE_SHORTCUT}/{RULE_NAME} => PKG = '@scope/bpmnlint-plugin-{PACKAGE_SHORTCUT}'
  	   */

  	  const match = /^(?:(?:(@[^/]+)\/)?([^@]{1}[^/]*)\/)?([^/]+)$/.exec(name);

  	  if (!match) {
  	    throw new Error(`unparseable rule name <${name}>`);
  	  }

  	  const [
  	    _,
  	    ns,
  	    packageName,
  	    ruleName
  	  ] = match;

  	  if (!packageName) {
  	    return {
  	      pkg: localPackage,
  	      ruleName
  	    };
  	  }

  	  const pkg = `${ns ? ns + '/' : '' }${prefixPackage(packageName)}`;

  	  return {
  	    pkg,
  	    ruleName
  	  };
  	};


  	Linter.prototype.parseConfigName = function(name) {

  	  /**
  	   * We recognize the following config name patterns:
  	   *
  	   * bpmnlint:{CONFIG_NAME} => PKG = 'bpmnlint'
  	   * plugin:{PACKAGE_SHORTCUT}/{CONFIG_NAME} => PKG = 'bpmnlint-plugin-{PACKAGE_SHORTCUT}'
  	   * plugin:bpmnlint-plugin-{PACKAGE_SHORTCUT}/{CONFIG_NAME} => PKG = 'bpmnlint-plugin-{PACKAGE_SHORTCUT}'
  	   * plugin:@scope/{PACKAGE_SHORTCUT}/{CONFIG_NAME} => PKG = '@scope/bpmnlint-plugin-{PACKAGE_SHORTCUT}'
  	   * plugin:@scope/bpmnlint-plugin-{PACKAGE_SHORTCUT}/{CONFIG_NAME} => PKG = '@scope/bpmnlint-plugin-{PACKAGE_SHORTCUT}'
  	   */

  	  const match = /^(?:(?:plugin:(?:(@[^/]+)\/)?([^@]{1}[^/]*)\/)|bpmnlint:)([^/]+)$/.exec(name);

  	  if (!match) {
  	    throw new Error(`unparseable config name <${name}>`);
  	  }

  	  const [
  	    _,
  	    ns,
  	    packageName,
  	    configName
  	  ] = match;

  	  if (!packageName) {
  	    return {
  	      pkg: 'bpmnlint',
  	      configName
  	    };
  	  }

  	  const pkg = `${ns ? ns + '/' : '' }${prefixPackage(packageName)}`;

  	  return {
  	    pkg,
  	    configName
  	  };
  	};


  	Linter.prototype.getSimplePackageName = function(name) {

  	  /**
  	   * We recognize the following package name patterns:
  	   *
  	   * bpmnlint => PKG = 'bpmnlint'
  	   * {PACKAGE_SHORTCUT} => PKG = PACKAGE_SHORTCUT
  	   * bpmnlint-plugin-{PACKAGE_SHORTCUT}' => PKG = PACKAGE_SHORTCUT
  	   * @scope/{PACKAGE_SHORTCUT} => PKG = '@scope/{PACKAGE_SHORTCUT}'
  	   * @scope/bpmnlint-plugin-{PACKAGE_SHORTCUT}' => PKG = '@scope/PACKAGE_SHORTCUT'
  	   */

  	  const match = /^(?:(@[^/]+)\/)?([^/]+)$/.exec(name);

  	  if (!match) {
  	    throw new Error(`unparseable package name <${name}>`);
  	  }

  	  const [
  	    _,
  	    ns,
  	    packageName
  	  ] = match;

  	  return `${ns ? ns + '/' : '' }${unprefixPackage(packageName)}`;
  	};


  	/**
  	 * Validate and return validated config.
  	 *
  	 * @param  {Object} config
  	 * @param  {String} localPackage
  	 *
  	 * @return {Object} validated config
  	 */
  	Linter.prototype.normalizeConfig = function(config, localPackage) {

  	  const rules = config.rules || {};

  	  const validatedRules = Object.keys(rules).reduce((normalizedRules, name) => {

  	    const value = rules[name];

  	    const {
  	      pkg,
  	      ruleName
  	    } = this.parseRuleName(name, localPackage);

  	    const normalizedName = (
  	      pkg === 'bpmnlint'
  	        ? ruleName
  	        : `${this.getSimplePackageName(pkg)}/${ruleName}`
  	    );

  	    normalizedRules[normalizedName] = value;

  	    return normalizedRules;
  	  }, {});

  	  return {
  	    ...config,
  	    rules: validatedRules
  	  };
  	};


  	// helpers ///////////////////////////

  	function prefixPackage(pkg) {

  	  if (pkg === 'bpmnlint') {
  	    return 'bpmnlint';
  	  }

  	  if (pkg.startsWith('bpmnlint-plugin-')) {
  	    return pkg;
  	  }

  	  return `bpmnlint-plugin-${pkg}`;
  	}


  	function unprefixPackage(pkg) {

  	  if (pkg.startsWith('bpmnlint-plugin-')) {
  	    return pkg.substring('bpmnlint-plugin-'.length);
  	  }

  	  return pkg;
  	}
  	return linter;
  }

  var lib;
  var hasRequiredLib;

  function requireLib () {
  	if (hasRequiredLib) return lib;
  	hasRequiredLib = 1;
  	const Linter = requireLinter();

  	lib = {
  	  Linter
  	};
  	return lib;
  }

  var libExports = requireLib();

  /**
   * Flatten array, one level deep.
   *
   * @template T
   *
   * @param {T[][] | T[] | null} [arr]
   *
   * @return {T[]}
   */

  const nativeToString = Object.prototype.toString;
  const nativeHasOwnProperty = Object.prototype.hasOwnProperty;

  function isUndefined(obj) {
    return obj === undefined;
  }

  function isNil(obj) {
    return obj == null;
  }

  function isArray(obj) {
    return nativeToString.call(obj) === '[object Array]';
  }

  /**
   * @param {any} obj
   *
   * @return {boolean}
   */
  function isFunction(obj) {
    const tag = nativeToString.call(obj);

    return (
      tag === '[object Function]' ||
      tag === '[object AsyncFunction]' ||
      tag === '[object GeneratorFunction]' ||
      tag === '[object AsyncGeneratorFunction]' ||
      tag === '[object Proxy]'
    );
  }

  /**
   * Return true, if target owns a property with the given key.
   *
   * @param {Object} target
   * @param {String} key
   *
   * @return {Boolean}
   */
  function has(target, key) {
    return !isNil(target) && nativeHasOwnProperty.call(target, key);
  }


  /**
   * Iterate over collection; returning something
   * (non-undefined) will stop iteration.
   *
   * @template T
   * @param {Collection<T>} collection
   * @param { ((item: T, idx: number) => (boolean|void)) | ((item: T, key: string) => (boolean|void)) } iterator
   *
   * @return {T} return result that stopped the iteration
   */
  function forEach(collection, iterator) {

    let val,
        result;

    if (isUndefined(collection)) {
      return;
    }

    const convertKey = isArray(collection) ? toNum : identity;

    for (let key in collection) {

      if (has(collection, key)) {
        val = collection[key];

        result = iterator(val, convertKey(key));

        if (result === false) {
          return val;
        }
      }
    }
  }


  /**
   * Reduce collection, returning a single result.
   *
   * @template T
   * @template V
   *
   * @param {Collection<T>} collection
   * @param {(result: V, entry: T, index: any) => V} iterator
   * @param {V} result
   *
   * @return {V} result returned from last iterator
   */
  function reduce(collection, iterator, result) {

    forEach(collection, function(value, idx) {
      result = iterator(result, value, idx);
    });

    return result;
  }


  /**
   * Transform a collection into another collection
   * by piping each member through the given fn.
   *
   * @param  {Object|Array}   collection
   * @param  {Function} fn
   *
   * @return {Array} transformed collection
   */
  function map$1(collection, fn) {

    let result = [];

    forEach(collection, function(val, key) {
      result.push(fn(val, key));
    });

    return result;
  }


  /**
   * Group collection members by attribute.
   *
   * @param {Object|Array} collection
   * @param {Extractor} extractor
   *
   * @return {Object} map with { attrValue => [ a, b, c ] }
   */
  function groupBy(collection, extractor, grouped = {}) {

    extractor = toExtractor(extractor);

    forEach(collection, function(val) {
      let discriminator = extractor(val) || '_';

      let group = grouped[discriminator];

      if (!group) {
        group = grouped[discriminator] = [];
      }

      group.push(val);
    });

    return grouped;
  }


  /**
   * @param {string | ((e: any) => any) } extractor
   *
   * @return { (e: any) => any }
   */
  function toExtractor(extractor) {

    /**
     * @satisfies { (e: any) => any }
     */
    return isFunction(extractor) ? extractor : (e) => {

      // @ts-ignore: just works
      return e[extractor];
    };
  }


  function identity(arg) {
    return arg;
  }

  function toNum(arg) {
    return Number(arg);
  }

  /**
   * Convenience wrapper for `Object.assign`.
   *
   * @param {Object} target
   * @param {...Object} others
   *
   * @return {Object} the target
   */
  function assign(target, ...others) {
    return Object.assign(target, ...others);
  }

  /**
   * Expose `parse`.
   */

  var domify = parse;

  /**
   * Tests for browser support.
   */

  var innerHTMLBug = false;
  var bugTestDiv;
  if (typeof document !== 'undefined') {
    bugTestDiv = document.createElement('div');
    // Setup
    bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
    // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE
    innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;
    bugTestDiv = undefined;
  }

  /**
   * Wrap map from jquery.
   */

  var map = {
    legend: [1, '<fieldset>', '</fieldset>'],
    tr: [2, '<table><tbody>', '</tbody></table>'],
    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
    // for script/link/style tags to work in IE6-8, you have to wrap
    // in a div with a non-whitespace character in front, ha!
    _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
  };

  map.td =
  map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

  map.option =
  map.optgroup = [1, '<select multiple="multiple">', '</select>'];

  map.thead =
  map.tbody =
  map.colgroup =
  map.caption =
  map.tfoot = [1, '<table>', '</table>'];

  map.polyline =
  map.ellipse =
  map.polygon =
  map.circle =
  map.text =
  map.line =
  map.path =
  map.rect =
  map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">','</svg>'];

  /**
   * Parse `html` and return a DOM Node instance, which could be a TextNode,
   * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
   * instance, depending on the contents of the `html` string.
   *
   * @param {String} html - HTML string to "domify"
   * @param {Document} doc - The `document` instance to create the Node for
   * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
   * @api private
   */

  function parse(html, doc) {
    if ('string' != typeof html) throw new TypeError('String expected');

    // default to the global `document` object
    if (!doc) doc = document;

    // tag name
    var m = /<([\w:]+)/.exec(html);
    if (!m) return doc.createTextNode(html);

    html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

    var tag = m[1];

    // body support
    if (tag == 'body') {
      var el = doc.createElement('html');
      el.innerHTML = html;
      return el.removeChild(el.lastChild);
    }

    // wrap map
    var wrap = Object.prototype.hasOwnProperty.call(map, tag) ? map[tag] : map._default;
    var depth = wrap[0];
    var prefix = wrap[1];
    var suffix = wrap[2];
    var el = doc.createElement('div');
    el.innerHTML = prefix + html + suffix;
    while (depth--) el = el.lastChild;

    // one element
    if (el.firstChild == el.lastChild) {
      return el.removeChild(el.firstChild);
    }

    // several elements
    var fragment = doc.createDocumentFragment();
    while (el.firstChild) {
      fragment.appendChild(el.removeChild(el.firstChild));
    }

    return fragment;
  }

  var domify$1 = domify;

  /**
   * @param {string} str
   *
   * @return {string}
   */

  var HTML_ESCAPE_MAP = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&#39;'
  };

  /**
   * @param {string} str
   *
   * @return {string}
   */
  function escapeHTML(str) {
    str = '' + str;

    return str && str.replace(/[&<>"']/g, function(match) {
      return HTML_ESCAPE_MAP[match];
    });
  }

  /**
   * @typedef { import('../model/Types').Element } Element
   * @typedef { import('../model/Types').ModdleElement } ModdleElement
   */

  /**
   * Is an element of the given BPMN type?
   *
   * @param  {Element|ModdleElement} element
   * @param  {string} type
   *
   * @return {boolean}
   */
  function is(element, type) {
    var bo = getBusinessObject(element);

    return bo && (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);
  }

  /**
   * Return the business object for a given element.
   *
   * @param {Element|ModdleElement} element
   *
   * @return {ModdleElement}
   */
  function getBusinessObject(element) {
    return (element && element.businessObject) || element;
  }

  var ErrorSvg = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   version=\"1.1\"\n   viewBox=\"0 0 512 512\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\">\n  <path\n     d=\"M 339.07183,256.00001 463.66713,131.4047 c 15.28961,-15.2896 15.28961,-40.079175 0,-55.381227 l -27.6906,-27.690611 c -15.28961,-15.289602 -40.07917,-15.289602 -55.38123,0 L 256,172.92818 131.4047,48.332862 c -15.2896,-15.289602 -40.079177,-15.289602 -55.381228,0 L 48.332861,76.023473 c -15.2896,15.2896 -15.2896,40.079177 0,55.381227 L 172.92815,256.00001 48.332861,380.59531 c -15.2896,15.2896 -15.2896,40.07917 0,55.38123 l 27.690611,27.69061 c 15.289601,15.28959 40.091628,15.28959 55.381228,0 L 256,339.07184 380.5953,463.66715 c 15.2896,15.28959 40.09162,15.28959 55.38123,0 l 27.6906,-27.69061 c 15.28961,-15.2896 15.28961,-40.07918 0,-55.38123 z\"\n     fill=\"currentColor\" />\n</svg>\n";

  var WarningSvg = "<svg version=\"1.1\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"m256 323.95c-45.518 0-82.419 34.576-82.419 77.229 0 42.652 36.9 77.229 82.419 77.229 45.518 0 82.419-34.577 82.419-77.23 0-42.652-36.9-77.229-82.419-77.229zm-80.561-271.8 11.61 204.35c.544 9.334 8.78 16.64 18.755 16.64h100.39c9.975 0 18.211-7.306 18.754-16.64l11.611-204.35c.587-10.082-7.98-18.56-18.754-18.56h-123.62c-10.775 0-19.34 8.478-18.753 18.56z\" fill=\"currentColor\"/>\n</svg>\n";

  var SuccessSvg = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   viewBox=\"0 0 512 512\"\n   version=\"1.1\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\">\n  <path\n     fill=\"currentColor\"\n     d=\"m 173.898,439.40356 -166.4,-166.4 c -9.997,-9.997 -9.997,-26.206 0,-36.204 l 36.203,-36.204 c 9.997,-9.998 26.207,-9.998 36.204,0 L 192,312.68956 432.095,72.595562 c 9.997,-9.997 26.207,-9.997 36.204,0 l 36.203,36.203998 c 9.997,9.997 9.997,26.206 0,36.204 l -294.4,294.401 c -9.998,9.997 -26.207,9.997 -36.204,-10e-4 z\" />\n</svg>\n";

  var InfoSvg = "<svg\n  viewBox=\"3.5 3.5 9 9\"\n  version=\"1.1\"\n  xmlns=\"http://www.w3.org/2000/svg\">\n  <path\n    fill=\"currentColor\" d=\"M6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path>\n</svg>";

  var OFFSET_TOP = -7,
      OFFSET_RIGHT = -7;

  var LOW_PRIORITY = 500;

  var emptyConfig = {
    resolver: {
      resolveRule: function() {
        return null;
      }
    },
    config: {}
  };

  var stateToIcon = {
    error: ErrorSvg,
    warning: WarningSvg,
    success: SuccessSvg,
    info: InfoSvg,
    inactive: SuccessSvg
  };

  function Linting(
      bpmnjs,
      canvas,
      config,
      elementRegistry,
      eventBus,
      overlays,
      translate
  ) {
    this._bpmnjs = bpmnjs;
    this._canvas = canvas;
    this._elementRegistry = elementRegistry;
    this._eventBus = eventBus;
    this._overlays = overlays;
    this._translate = translate;

    this._issues = {};

    this._active = config && config.active || false;
    this._linterConfig = emptyConfig;

    this._overlayIds = {};

    var self = this;

    eventBus.on([
      'import.done',
      'elements.changed',
      'linting.configChanged',
      'linting.toggle'
    ], LOW_PRIORITY, function(e) {
      self.update();
    });

    eventBus.on('linting.toggle', function(event) {

      const active = event.active;

      if (!active) {
        self._clearIssues();
        self._updateButton();
      }
    });

    eventBus.on('diagram.clear', function() {
      self._clearIssues();
    });

    var linterConfig = config && config.bpmnlint;

    linterConfig && eventBus.once('diagram.init', function() {

      // bail out if config was already provided
      // during initialization of other modules
      if (self.getLinterConfig() !== emptyConfig) {
        return;
      }

      try {
        self.setLinterConfig(linterConfig);
      } catch (err) {
        console.error(
          '[bpmn-js-bpmnlint] Invalid lint rules configured. ' +
          'Please doublecheck your linting.bpmnlint configuration, ' +
          'cf. https://github.com/bpmn-io/bpmn-js-bpmnlint#configure-lint-rules'
        );
      }
    });

    this._init();
  }

  Linting.prototype.setLinterConfig = function(linterConfig) {

    if (!linterConfig.config || !linterConfig.resolver) {
      throw new Error('Expected linterConfig = { config, resolver }');
    }

    this._linterConfig = linterConfig;

    this._eventBus.fire('linting.configChanged');
  };

  Linting.prototype.getLinterConfig = function() {
    return this._linterConfig;
  };

  Linting.prototype._init = function() {
    this._createButton();

    this._updateButton();
  };

  Linting.prototype.isActive = function() {
    return this._active;
  };

  Linting.prototype._formatIssues = function(issues) {

    let self = this;

    // (1) reduce issues to flat list of issues including the affected element
    let reports = reduce(issues, function(reports, ruleReports, rule) {

      return reports.concat(ruleReports.map(function(report) {
        report.rule = rule;

        return report;
      }));

    }, []);

    // (2) if affected element is not visible, then report it on root or participant level
    const participants = self._elementRegistry.filter((ele) => { return is(ele, 'bpmn:Participant'); }),
          participantBos = participants.map((ele) => { return ele.businessObject; });

    reports = map$1(reports, function(report) {
      const element = self._elementRegistry.get(report.id);

      if (!element) {
        report.isChildIssue = true;
        report.actualElementId = report.id;

        // (2.1) Is a participant referring to the current issue? Then display on participant
        const referringParticipant = participantBos.filter((ele) => {
          return (ele.processRef && ele.processRef.id && ele.processRef.id === report.id);
        });

        if (referringParticipant.length) {
          report.id = referringParticipant[0].id;
        } else {

          // (2.2) If there is no participant to display it on, display it to root
          report.id = self._canvas.getRootElement().id;
        }

      }

      return report;
    });

    // (3) group issues per elementId (resulting in ie. [elementId1: [{issue1}, {issue2}]] structure)
    reports = groupBy(reports, function(report) {
      return report.id;
    });

    return reports;

  };

  /**
   * Toggle linting on or off.
   *
   * @param {boolean} [newActive]
   *
   * @return {boolean} the new active state
   */
  Linting.prototype.toggle = function(newActive) {

    newActive = typeof newActive === 'undefined' ? !this.isActive() : newActive;

    this._setActive(newActive);

    return newActive;
  };

  Linting.prototype._setActive = function(active) {

    if (this._active === active) {
      return;
    }

    this._active = active;

    this._eventBus.fire('linting.toggle', { active: active });
  };

  /**
   * Update overlays. Always lint and check whether overlays need update or not.
   */
  Linting.prototype.update = function() {
    var self = this;

    var definitions = this._bpmnjs.getDefinitions();

    if (!definitions) {
      return;
    }

    var lintStart = this._lintStart = Math.random();

    this.lint().then(function(newIssues) {

      if (self._lintStart !== lintStart) {
        return;
      }

      newIssues = self._formatIssues(newIssues);

      var remove = {},
          update = {},
          add = {};

      for (var id1 in self._issues) {
        if (!newIssues[id1]) {
          remove[id1] = self._issues[id1];
        }
      }

      for (var id2 in newIssues) {
        if (!self._issues[id2]) {
          add[id2] = newIssues[id2];
        } else {
          if (newIssues[id2] !== self._issues[id2]) {
            update[id2] = newIssues[id2];
          }
        }
      }

      remove = assign(remove, update);
      add = assign(add, update);

      self._clearOverlays();

      if (self.isActive()) {
        self._createIssues(add);
      }

      self._issues = newIssues;

      self._updateButton();

      self._fireComplete(newIssues);
    });
  };

  Linting.prototype._fireComplete = function(issues) {
    this._eventBus.fire('linting.completed', { issues: issues });
  };

  Linting.prototype._createIssues = function(issues) {
    for (var id in issues) {
      this._createElementIssues(id, issues[id]);
    }
  };

  /**
   * Create overlay including all issues which are given for a single element.
   *
   * @param {string} elementId - id of element, for which the issue shall be displayed.
   * @param {Array} elementIssues - All element issues including warnings and errors.
   */
  Linting.prototype._createElementIssues = function(elementId, elementIssues) {
    var element = this._elementRegistry.get(elementId);

    if (!element) {
      return;
    }

    // Also attach element to subprocess plane
    var plane = this._elementRegistry.get(elementId + '_plane');
    if (plane) {
      this._createElementIssues(plane.id, elementIssues);
    }

    var menuPosition;
    var position;

    var isRoot = !element.parent;
    if (isRoot && is(element, 'bpmn:Process')) {
      menuPosition = 'bottom-right';

      position = {
        top: 20,
        left: 150
      };
    } else if (isRoot && is(element, 'bpmn:SubProcess')) {
      menuPosition = 'bottom-right';

      position = {
        top: 50,
        left: 150
      };
    } else {
      menuPosition = 'top-right';

      position = {
        top: OFFSET_TOP,
        left: OFFSET_RIGHT
      };
    }

    var issuesByType = groupBy(elementIssues, function(elementIssue) {
      return (elementIssue.isChildIssue ? 'child' : '') + elementIssue.category;
    });

    var errors = issuesByType.error,
        warnings = issuesByType.warn,
        infos = issuesByType.info,
        childErrors = issuesByType.childerror,
        childWarnings = issuesByType.childwarn,
        childInfos = issuesByType.childinfo;

    if (
      !infos &&
      !errors &&
      !warnings &&
      !childErrors &&
      !childWarnings &&
      !childInfos
    ) {
      return;
    }

    var $html = domify$1(
      '<div class="bjsl-overlay bjsl-issues-' + menuPosition + '"></div>'
    );

    var $icon = (errors || childErrors)
      ? domify$1('<div class="bjsl-icon bjsl-icon-error">' + ErrorSvg + '</div>')
      : (warnings || childWarnings)
        ? domify$1('<div class="bjsl-icon bjsl-icon-warning">' + WarningSvg + '</div>')
        : domify$1('<div class="bjsl-icon bjsl-icon-info">' + InfoSvg + '</div>');

    var $dropdown = domify$1('<div class="bjsl-dropdown"></div>');
    var $dropdownContent = domify$1('<div class="bjsl-dropdown-content"></div>');

    var $issueContainer = domify$1('<div class="bjsl-issues"></div>');

    var $issues = domify$1('<div class="bjsl-current-element-issues"></div>');
    var $issueList = domify$1('<ul></ul>');

    $html.appendChild($icon);
    $html.appendChild($dropdown);

    $dropdown.appendChild($dropdownContent);
    $dropdownContent.appendChild($issueContainer);

    $issueContainer.appendChild($issues);

    $issues.appendChild($issueList);

    // Add errors and warnings to issueList
    if (errors) {
      this._addErrors($issueList, errors);
    }

    if (warnings) {
      this._addWarnings($issueList, warnings);
    }

    if (infos) {
      this._addInfos($issueList, infos);
    }

    // If errors or warnings for child elements of the current element are to be displayed,
    // then add an additional list
    if (childErrors || childWarnings || childInfos) {
      var $childIssues = domify$1('<div class="bjsl-child-issues"></div>');
      var $childIssueList = domify$1('<ul></ul>');
      var childLabel = this._translate('Issues for child elements');
      var $childIssueLabel = domify$1('<a class="bjsl-issue-heading">' + childLabel + ':</a>');

      if (childErrors) {
        this._addErrors($childIssueList, childErrors);
      }

      if (childWarnings) {
        this._addWarnings($childIssueList, childWarnings);
      }

      if (childInfos) {
        this._addInfos($childIssueList, childInfos);
      }

      if (errors || warnings) {
        var $childIssuesSeparator = domify$1('<hr/>');
        $childIssues.appendChild($childIssuesSeparator);
      }

      $childIssues.appendChild($childIssueLabel);
      $childIssues.appendChild($childIssueList);
      $issueContainer.appendChild($childIssues);
    }

    this._overlayIds[elementId] = this._overlays.add(element, 'linting', {
      position: position,
      html: $html,
      scale: {
        min: .7
      }
    });
  };

  Linting.prototype._addErrors = function($ul, errors) {

    var self = this;

    errors.forEach(function(error) {
      self._addEntry($ul, 'error', error);
    });
  };

  Linting.prototype._addWarnings = function($ul, warnings) {

    var self = this;

    warnings.forEach(function(error) {
      self._addEntry($ul, 'warning', error);
    });
  };

  Linting.prototype._addInfos = function($ul, infos) {

    var self = this;

    infos.forEach(function(error) {
      self._addEntry($ul, 'info', error);
    });
  };

  Linting.prototype._addEntry = function($ul, state, entry) {

    var rule = entry.rule,
        documentationUrl = entry.meta?.documentation.url,
        message = this._translate(entry.message),
        actualElementId = entry.actualElementId;

    var icon = stateToIcon[state];

    var $entry = domify$1(`
    <li class="${ state }" data-rule="${ escapeHTML(rule) }">
      <span class="icon">${ icon }</span>
      <span class="message">${ escapeHTML(message) }</span>
      <span class="rule">(${ documentationUrl
    ? `<a href="${ escapeHTML(documentationUrl) }" target="_blank">${ escapeHTML(rule) }</a>`
    : escapeHTML(rule) })</span>
      ${ actualElementId
    ? `<span class="bjsl-id-hint"><code>${ escapeHTML(actualElementId) }</code></span>`
    : '' }
    </li>
  `);

    $ul.appendChild($entry);
  };

  Linting.prototype._clearOverlays = function() {
    this._overlays.remove({ type: 'linting' });

    this._overlayIds = {};
  };

  Linting.prototype._clearIssues = function() {
    this._issues = {};

    this._clearOverlays();
  };

  Linting.prototype._setButtonState = function(issues) {
    var {
      errors,
      warnings,
      infos
    } = issues;

    var button = this._button;

    var state = (errors && 'error') || (warnings && 'warning') || 'success';

    var icon = stateToIcon[state];
    var label = this._translate(
      (errors || warnings)
        ? '{errors} Errors, {warnings} Warnings'
        : 'No Issues',
      {
        errors: String(errors),
        warnings: String(warnings),
        infos: String(infos),
      }
    );

    var html = `
    <span class="icon">${icon}</span>
    <span>${ label }</span>`;

    state = this.isActive() ? state : 'inactive';

    [
      'error',
      'inactive',
      'success',
      'warning'
    ].forEach(function(s) {
      if (state === s) {
        button.classList.add('bjsl-button-' + s);
      } else {
        button.classList.remove('bjsl-button-' + s);
      }
    });

    button.innerHTML = html;
  };

  Linting.prototype._updateButton = function() {

    var errors = 0,
        warnings = 0,
        infos = 0;

    for (var id in this._issues) {
      this._issues[id].forEach(function(issue) {
        if (issue.category === 'error') {
          errors++;
        } else if (issue.category === 'warn') {
          warnings++;
        } else if (issue.category === 'info') {
          infos++;
        }
      });
    }

    this._setButtonState({
      errors,
      warnings,
      infos
    });
  };

  Linting.prototype._createButton = function() {

    var self = this;

    this._button = domify$1(
      '<button class="bjsl-button bjsl-button-inactive" title="' + this._translate('Toggle linting overlays') + '"></button>'
    );

    this._button.addEventListener('click', function() {
      self.toggle();
    });

    this._canvas.getContainer().appendChild(this._button);
  };

  Linting.prototype.lint = function() {
    var definitions = this._bpmnjs.getDefinitions();

    var linter = new libExports.Linter(this._linterConfig);

    return linter.lint(definitions);
  };

  Linting.$inject = [
    'bpmnjs',
    'canvas',
    'config.linting',
    'elementRegistry',
    'eventBus',
    'overlays',
    'translate'
  ];

  var index = {
    __init__: [ 'linting', 'lintingEditorActions' ],
    linting: [ 'type', Linting ],
    lintingEditorActions: [ 'type', EditorActions ]
  };

  return index;

}));
